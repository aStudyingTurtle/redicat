# RNA Editing Utilities

This workspace contains two standalone Python scripts for processing single-cell RNA sequencing data into RNA editing metrics. Each script is self-contained and exposes a command line interface so the processing steps can be chained in larger pipelines or executed manually.

## `bam2mtx.py`

### Purpose

`bam2mtx.py` converts per-base information stored in an aligned BAM file into an `AnnData` object containing strand-aware base counts. It reads a whitelist of cell barcodes, a list of genomic loci to interrogate, and aggregates counts per cell/position, producing an `.h5ad` matrix ready for downstream analysis.

### Key implementation points

- Uses `pysam` to iterate pileups with high mapping and base-quality thresholds (255 / 30 by default).
- Handles stranded and unstranded protocols via a CLI flag, emitting eight (A+/T+/G+/C+/A-/T-/G-/C-) or four (A/T/G/C) layers respectively.
- Constructs sparse CSC matrices for efficiency and stores them in the `.layers` field of the resulting `AnnData` object.
- Parallelises locus processing with Python's multiprocessing pool; chunk size and worker count are configurable.

### Usage

```powershell
python .\bam2mtx.py `
  --threads 8 `
  --barcodes data\cells.tsv.gz `
  --bam data\aligned.bam `
  --sites data\editing_sites.tsv `
  --output-h5ad outputs\base_counts.h5ad
```

Add `--unstranded` if the experiment does not preserve strand information. Adjust `--chunk-size` to tune memory/performance trade-offs.

## `call.py`

### Purpose

`call.py` consumes the base-count `AnnData` generated by `bam2mtx.py`, augments it with editing-site annotations, and derives ref/alt matrices along with Composite Editing Index (CEI) values for each cell.

### Key implementation points

- Loads site metadata from JSON, TSV, CSV, or Parquet files; the index (or a column such as `site`, `id`, `name`, `position`, or `pos`) must match the `AnnData.var_names`.
- Filters genomic positions by chromosome prefix (`chr`) and minimum coverage before computing summary layers.
- Aggregates strand-specific counts into positive/negative totals and annotates ref/alt/other layers via sparse operations to preserve memory efficiency.
- Supports chunked processing for very large datasets and exposes both AG and CU editing modes.
- Computes CEI scores while guarding against division-by-zero cases.

### Usage

```powershell
python .\call.py `
  --input-h5ad outputs\base_counts.h5ad `
  --editing-sites data\editing_annotations.tsv `
  --output-h5ad outputs\editing_calls.h5ad `
  --editing-type AG `
  --min-coverage 5
```

Specify `--chunk-size` to process the dataset in batches if memory is constrained. The script expects the annotation file to supply at least a reference base (`ref` column); additional columns such as `Stranded`, `Mismatch`, `Mismatch_P`, and `Mismatch_N` are mapped onto `AnnData.var` when present.

## Requirements

Both scripts rely on the following Python packages:

- `anndata`
- `numpy`
- `pandas`
- `scipy`
- `scanpy` (for reading/writing `.h5ad` files and utility functions)
- `scikit-learn` (for one-hot encoding in `call.py`)
- `pysam` (`bam2mtx.py` only)

Install them via `pip install anndata numpy pandas scipy scanpy scikit-learn pysam` or your preferred environment manager.

## Suggested workflow

1. Run `bam2mtx.py` on aligned reads and locus definitions to obtain strand-aware base count matrices.
2. Provide the resulting `.h5ad` file and editing-site annotations to `call.py` to generate ref/alt layers and CEI scores.
3. Use the enriched `AnnData` output for downstream visualisation or statistical analysis.

Both scripts validate critical inputs and will raise descriptive errors if required dependencies or files are missing.
